<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <meta name="renderer" content="webkit">
  <meta http-equiv="X-UA-Compatible" content="IE=edge" >
  <link rel="dns-prefetch" href="http://www.gengjf.com">
  <title>组件化架构漫谈 | Gengjf</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="原文链接：http://ios.jobbole.com/89044/
前段时间公司项目打算重构，准确来说应该是按之前的产品逻辑重写一个项目😂。在重构项目之前涉及到架构选型的问题，我和组里小伙伴一起研究了一下组件化架构，打算将项目重构为组件化架构。当然不是直接拿来照搬，还是要根据公司具体的业务需求设计架构。   在学习组件化架构的过程中，从很多高质量的博客中学到不少东西，例如蘑菇街李忠、casat">
<meta property="og:type" content="article">
<meta property="og:title" content="组件化架构漫谈">
<meta property="og:url" content="http://www.gengjf.com/2016/11/08/组件化架构漫谈/index.html">
<meta property="og:site_name" content="Gengjf">
<meta property="og:description" content="原文链接：http://ios.jobbole.com/89044/
前段时间公司项目打算重构，准确来说应该是按之前的产品逻辑重写一个项目😂。在重构项目之前涉及到架构选型的问题，我和组里小伙伴一起研究了一下组件化架构，打算将项目重构为组件化架构。当然不是直接拿来照搬，还是要根据公司具体的业务需求设计架构。   在学习组件化架构的过程中，从很多高质量的博客中学到不少东西，例如蘑菇街李忠、casat">
<meta property="og:image" content="http://www.gengjf.com/images/zjhjgmt/ohyzgc.png">
<meta property="og:image" content="http://www.gengjf.com/images/zjhjgmt/tjzjc.png">
<meta property="og:image" content="http://www.gengjf.com/images/zjhjgmt/zjhjg.png">
<meta property="og:image" content="http://www.gengjf.com/images/zjhjgmt/MGJRouterzjhjg.png">
<meta property="og:image" content="http://www.gengjf.com/images/zjhjgmt/Protocolzjj.png">
<meta property="og:image" content="http://www.gengjf.com/images/zjhjgmt/casatwyzjhjg.png">
<meta property="og:image" content="http://www.gengjf.com/images/zjhjgmt/casatwyzjxj.png">
<meta property="og:image" content="http://www.gengjf.com/images/zjhjgmt/wjml.png">
<meta property="og:image" content="http://www.gengjf.com/images/zjhjgmt/zjhjgt.png">
<meta property="og:image" content="http://www.gengjf.com/images/zjhjgmt/gszjhjg.png">
<meta property="og:image" content="http://www.gengjf.com/images/zjhjgmt/tbscjg.png">
<meta property="og:image" content="http://www.gengjf.com/images/zjhjgmt/zxsj.png">
<meta property="og:image" content="http://www.gengjf.com/images/zjhjgmt/BundleApp.png">
<meta property="og:updated_time" content="2016-11-08T07:20:12.000Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="组件化架构漫谈">
<meta name="twitter:description" content="原文链接：http://ios.jobbole.com/89044/
前段时间公司项目打算重构，准确来说应该是按之前的产品逻辑重写一个项目😂。在重构项目之前涉及到架构选型的问题，我和组里小伙伴一起研究了一下组件化架构，打算将项目重构为组件化架构。当然不是直接拿来照搬，还是要根据公司具体的业务需求设计架构。   在学习组件化架构的过程中，从很多高质量的博客中学到不少东西，例如蘑菇街李忠、casat">
<meta name="twitter:image" content="http://www.gengjf.com/images/zjhjgmt/ohyzgc.png">
  
    <link rel="alternative" href="/atom.xml" title="Gengjf" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.ico">
  
  <link rel="stylesheet" href="/main.css">
  

</head>

<body>
  <div id="container">
    <div class="left-col">
      <div class="overlay"></div>
<div class="intrude-less">
	<header id="header" class="inner">
		<a href="/" class="profilepic">
			
			<img src="/avatar.png" class="js-avatar">
			
		</a>

		<hgroup>
		  <h1 class="header-author"><a href="/">Gengjf</a></h1>
		</hgroup>

		

		<nav class="header-menu">
			<ul>
			
				<li><a href="/">主页</a></li>
	        
				<li><a href="/tags/随笔">随笔</a></li>
	        
				<li><a href="/tags/iOS">iOS</a></li>
	        
				<li><a href="/tags/Android">Android</a></li>
	        
			</ul>
		</nav>
		<nav class="header-smart-menu">
	        
    		
    			
    			<a class="js-smart-menu" data-idx="0" href="javascript:void(0)">所有文章</a>
    			
    			
            
    			
    			<a class="js-smart-menu" data-idx="1" href="javascript:void(0)">关于我</a>
    			
    			
            
		</nav>
		<nav class="header-nav">
			<div class="social">
				
			</div>
		</nav>
	</header>		
</div>

    </div>
    <div class="mid-col">
      <nav id="mobile-nav">
  	<div class="overlay">
  		<div class="slider-trigger"><i class="icon-list"></i></div>
  		<h1 class="header-author js-mobile-header hide">Gengjf</h1>
  	</div>
	<div class="intrude-less">
		<header id="header" class="inner">
			<div class="profilepic">
				
					<img src="/avatar.png" class="js-avatar">
				
			</div>
			<hgroup>
			  <h1 class="header-author">Gengjf</h1>
			</hgroup>
			
			<nav class="header-menu">
				<ul>
				
					<li><a href="/">主页</a></li>
		        
					<li><a href="/tags/随笔">随笔</a></li>
		        
					<li><a href="/tags/iOS">iOS</a></li>
		        
					<li><a href="/tags/Android">Android</a></li>
		        
				</ul>
			</nav>
			<nav class="header-nav">
				<div class="social">
					
				</div>
			</nav>
		</header>				
	</div>
</nav>

      <div class="body-wrap">
        <article id="post-组件化架构漫谈" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      组件化架构漫谈
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>原文链接：<a href="http://ios.jobbole.com/89044/" target="_blank" rel="external">http://ios.jobbole.com/89044/</a></p>
<p>前段时间公司项目打算重构，准确来说应该是按之前的产品逻辑重写一个项目😂。在重构项目之前涉及到架构选型的问题，我和组里小伙伴一起研究了一下组件化架构，打算将项目重构为组件化架构。当然不是直接拿来照搬，还是要根据公司具体的业务需求设计架构。<br>   在学习组件化架构的过程中，从很多高质量的博客中学到不少东西，例如蘑菇街李忠、casatwy、bang的博客。在学习过程中也遇到一些问题，在微博和QQ上和一些做iOS的朋友进行了交流，非常感谢这些朋友的帮助。<br>   本篇文章主要针对于之前蘑菇街提出的组件化方案，以及casatwy提出的组件化方案进行分析，后面还会简单提到滴滴、淘宝、微信的组件化架构，最后会简单说一下我公司设计的组件化架构。</p>
<h3 id="组件化架构的由来"><a href="#组件化架构的由来" class="headerlink" title="组件化架构的由来"></a>组件化架构的由来</h3><p>随着移动互联网的不断发展，很多程序代码量和业务越来越多，现有架构已经不适合公司业务的发展速度了，很多都面临着重构的问题。<br>在公司项目开发中，如果项目比较小，普通的单工程+MVC架构就可以满足大多数需求了。但是像淘宝、蘑菇街、微信这样的大型项目，原有的单工程架构就不足以满足架构需求了。</p>
<p>就拿淘宝来说，淘宝在13年开启的“All in 无线”战略中，就将阿里系大多数业务都加入到手机淘宝中，使客户端出现了业务的爆发。在这种情况下，单工程架构则已经远远不能满足现有业务需求了。所以在这种情况下，淘宝在13年开启了插件化架构的重构，后来在14年迎来了手机淘宝有史以来最大规模的重构，将其彻底重构为组件化架构。</p>
<h3 id="蘑菇街的组件化架构"><a href="#蘑菇街的组件化架构" class="headerlink" title="蘑菇街的组件化架构"></a>蘑菇街的组件化架构</h3><h4 id="原因"><a href="#原因" class="headerlink" title="原因"></a>原因</h4><p>在一个项目越来越大，开发人员越来越多的情况下，项目会遇到很多问题。</p>
<ul>
<li>业务模块间划分不清晰，模块之间耦合度很大，非常难维护。</li>
<li>所有模块代码都编写在一个项目中，测试某个模块或功能，需要编译运行整个项目。<br><img src="/images/zjhjgmt/ohyzgc.png" alt=""></li>
</ul>
<p>（耦合严重的工程）</p>
<p>为了解决上面的问题，可以考虑加一个中间层来协调模块间的调用，所有的模块间的调用都会经过中间层中转。(注意看两张图的箭头方向)</p>
<p><img src="/images/zjhjgmt/tjzjc.png" alt=""></p>
<p>（添加中间层）</p>
<p>但是发现增加这个中间层后，耦合还是存在的。中间层对被调用模块存在耦合，其他模块也需要耦合中间层才能发起调用。这样还是存在之前的相互耦合的问题，而且本质上比之前更麻烦了。</p>
<h4 id="大体结构"><a href="#大体结构" class="headerlink" title="大体结构"></a>大体结构</h4><p>所以应该做的是，只让其他模块对中间层产生耦合关系，中间层不对其他模块发生耦合。<br>对于这个问题，可以采用组件化的架构，将每个模块作为一个组件。并且建立一个主项目，这个主项目负责集成所有组件。这样带来的好处是很多的：</p>
<ul>
<li>业务划分更佳清晰，新人接手更佳容易，可以按组件分配开发任务。</li>
<li>项目可维护性更强，提高开发效率。</li>
<li>更好排查问题，某个组件出现问题，直接对组件进行处理。</li>
<li>开发测试过程中，可以只编译自己那部分代码，不需要编译整个项目代码。</li>
</ul>
<p><img src="/images/zjhjgmt/zjhjg.png" alt=""></p>
<p>（组件化结构）</p>
<p>进行组件化开发后，可以把每个组件当做一个独立的app，每个组件甚至可以采取不同的架构，例如分别使用MVVM、MVC、MVCS等架构。</p>
<h4 id="MGJRouter方案"><a href="#MGJRouter方案" class="headerlink" title="MGJRouter方案"></a>MGJRouter方案</h4><p>蘑菇街通过MGJRouter实现中间层，通过MGJRouter进行组件间的消息转发，从名字上来说更像是路由器。实现方式大致是，在提供服务的组件中提前注册block，然后在调用方组件中通过URL调用block，下面是调用方式。</p>
<h6 id="架构设计"><a href="#架构设计" class="headerlink" title="架构设计"></a>架构设计</h6><p><img src="/images/zjhjgmt/MGJRouterzjhjg.png" alt=""></p>
<p>（MGJRouter组件化架构）</p>
<p>MGJRouter是一个单例对象，在其内部维护着一个“URL -&gt; block”格式的注册表，通过这个注册表来保存服务方注册的block，以及使调用方可以通过URL映射出block，并通过MGJRouter对服务方发起调用。</p>
<p>在服务方组件中都对外提供一个接口类，在接口类内部实现block的注册工作，以及block对外提供服务的代码实现。每一个block都对应着一个URL，调用方可以通过URL对block发起调用。</p>
<p>在程序开始运行时，需要将所有服务方的接口类实例化，以完成这个注册工作，使MGJRouter中所有服务方的block可以正常提供服务。在这个服务注册完成后，就可以被调用方调起并提供服务。</p>
<p>蘑菇街项目使用git作为版本控制工具，将每个组件都当做一个独立工程，并建立主项目来集成所有组件。集成方式是在主项目中通过CocoaPods来集成，将所有组件当做二方库集成到项目中。详细的集成技术点在下面“标准组件化架构设计”章节中会讲到。</p>
<h6 id="MGJRouter调用"><a href="#MGJRouter调用" class="headerlink" title="MGJRouter调用"></a>MGJRouter调用</h6><p>代码模拟对详情页的注册、调用，在调用过程中传递id参数。下面是注册的示例代码：</p>
<pre><code>[MGJRouter registerURLPattern:@&quot;mgj://detail?id=id&quot; toHandler:^(NSDictionary *routerParameters) {
   // 下面可以在拿到参数后，为其他组件提供对应的服务
   NSString uid = routerParameters[@&quot;id&quot;];
}];
</code></pre><p>通过openURL:方法传入的URL参数，对详情页已经注册的block方法发起调用。调用方式类似于GET请求，URL地址后面拼接参数。</p>
<pre><code>[MGJRouter openURL:@&quot;mgj://detail?id=404&quot;];
</code></pre><p>也可以通过字典方式传参，MGJRouter提供了带有字典参数的方法，这样就可以传递非字符串之外的其他类型参数。</p>
<pre><code>[MGJRouter openURL:@&quot;mgj://detail?&quot; withParam:@{@&quot;id&quot; : @&quot;404&quot;}];
</code></pre><h6 id="组件间传值"><a href="#组件间传值" class="headerlink" title="组件间传值"></a>组件间传值</h6><p>有的时候组件间调用过程中，需要服务方在完成调用后返回相应的参数。蘑菇街提供了另外的方法，专门来完成这个操作。</p>
<pre><code>[MGJRouter registerURLPattern:@&quot;mgj://cart/ordercount&quot; toObjectHandler:^id(NSDictionary *routerParamters){
   return @42;
}];
</code></pre><p>通过下面的方式发起调用，并获取服务方返回的返回值，要做的就是传递正确的URL和参数即可。</p>
<pre><code>NSNumber *orderCount = [MGJRouter objectForURL:@&quot;mgj://cart/ordercount&quot;];
</code></pre><h6 id="短链管理"><a href="#短链管理" class="headerlink" title="短链管理"></a>短链管理</h6><p>这时候会发现一个问题，在蘑菇街组件化架构中，存在了很多硬编码的URL和参数。在代码实现过程中URL编写出错会导致调用失败，而且参数是一个字典类型，调用方不知道服务方需要哪些参数，这些都是个问题。</p>
<p>对于这些数据的管理，蘑菇街开发了一个web页面，这个web页面统一来管理所有的URL和参数，Android和iOS都使用这一套URL，可以保持统一性。</p>
<h6 id="基础组件"><a href="#基础组件" class="headerlink" title="基础组件"></a>基础组件</h6><p>在项目中存在很多公共部分的东西，例如封装的网络请求、缓存、数据处理等功能，以及项目中所用到的资源文件。</p>
<p>蘑菇街将这些部分也当做组件，划分为基础组件，位于业务组件下层。所有业务组件都使用同一个基础组件，也可以保证公共部分的统一性。</p>
<h4 id="Protocol方案"><a href="#Protocol方案" class="headerlink" title="Protocol方案"></a>Protocol方案</h4><h6 id="整体架构"><a href="#整体架构" class="headerlink" title="整体架构"></a>整体架构</h6><p><img src="/images/zjhjgmt/Protocolzjj.png" alt=""></p>
<p>（Protocol方案的中间件）</p>
<p>为了解决MGJRouter方案中URL硬编码，以及字典参数类型不明确等问题，蘑菇街在原有组件化方案的基础上推出了Protocol方案。Protocol方案由两部分组成，进行组件间通信的ModuleManager类以及MGJComponentProtocol协议类。</p>
<p>通过中间件ModuleManager进行消息的调用转发，在ModuleManager内部维护一张映射表，映射表由之前的”URL -&gt; block”变成”Protocol -&gt; Class”。<br>在中间件中创建MGJComponentProtocol文件，服务方组件将可以用来调用的方法都定义在Protocol中，将所有服务方的Protocol都分别定义到MGJComponentProtocol文件中，如果协议比较多也可以分开几个文件定义。这样所有调用方依然是只依赖中间件，不需要依赖除中间件之外的其他组件。</p>
<p>Protocol方案中每个组件也需要一个“接口类”，此类负责实现当前组件对应的协议方法，也就是对外提供服务的实现。在程序开始运行时将自身的Class注册到ModuleManager中，并将Protocol反射出字符串当做key。这个注册过程和MGJRouter是类似的，都需要提前注册服务。</p>
<h6 id="示例代码"><a href="#示例代码" class="headerlink" title="示例代码"></a>示例代码</h6><p>创建MGJUserImpl类当做User模块的服务类，并在MGJComponentProtocol.h中定义MGJUserProtocol协议，由MGJUserImpl类实现协议中定义的方法，完成对外提供服务的过程。下面是协议定义：</p>
<pre><code>@protocol MGJUserProtocol
- (NSString *)getUserName;
@end
</code></pre><p>Class遵守协议并实现定义的方法，外界通过Protocol获取的Class实例化为对象，调用服务方实现的协议方法。</p>
<p>ModuleManager的协议注册方法，注册时将Protocol反射为字符串当做存储的key，将实现协议的Class当做值存储。通过Protocol取Class的时候，就是通过Protocol从ModuleManager中将Class映射出来。</p>
<pre><code>[ModuleManager registerClass:MGJUserImpl forProtocol:@protocol(MGJUserProtocol)];
</code></pre><p>调用时通过Protocol从ModuleManager中映射出注册的Class，将获取到的Class实例化，并调用Class实现的协议方法完成服务调用。</p>
<pre><code>Class cls = [[ModuleManager sharedInstance] classForProtocol:@protocol(MGJUserProtocol)];
id userComponent = [[cls alloc] init];
NSString *userName = [userComponent getUserName];
</code></pre><h6 id="整体调用流程"><a href="#整体调用流程" class="headerlink" title="整体调用流程"></a>整体调用流程</h6><p>蘑菇街是OpenURL和Protocol混用的方式，两种实现的调用方式不同，但大体调用逻辑和实现思路类似，所以下面的调用流程二者差不多。在OpenURL不能满足需求或调用不方便时，就可以通过Protocol的方式调用。</p>
<ul>
<li>在进入程序后，先使用MGJRouter对服务方组件进行注册。每个URL对应一个block的实现，block中的代码就是服务方对外提供的服务，调用方可以通过URL调用这个服务。</li>
<li>调用方通过MGJRouter调用openURL:方法，并将被调用代码对应的URL传入，MGJRouter会根据URL查找对应的block实现，从而调用服务方组件的代码进行通信。</li>
<li>调用和注册block时，block有一个字典用来传递参数。这样的优势就是参数类型和数量理论上是不受限制的，但是需要很多硬编码的key名在项目中。</li>
</ul>
<h6 id="内存管理"><a href="#内存管理" class="headerlink" title="内存管理"></a>内存管理</h6><p>蘑菇街组件化方案有两种，Protocol和MGJRouter的方式，但都需要进行register操作。Protocol注册的是Class，MGJRouter注册的是Block，注册表是一个NSMutableDictionary类型的字典，而字典的拥有者又是一个单例对象，这样会造成内存的常驻。</p>
<p>下面是对两种实现方式内存消耗的分析：</p>
<ul>
<li>首先说一下block实现方式可能导致的内存问题，block如果使用不当，很容易造成循环引用的问题。</li>
<li>经过暴力测试，证明并不会导致内存问题。被保存在字典中是一个block对象，而block对象本身并不会占用多少内存。在调用block后会对block体中的方法进行执行，执行完成后block体中的对象释放。</li>
<li>而block自身的实现只是一个结构体，也就相当于字典中存放的是很多结构体，所以内存的占用并不是很大。</li>
<li>对于协议这种实现方式，和block内存常驻方式差不多。只是将存储的block对象换成Class对象，如果不是已经实例化的对象，内存占用还是比较小的。</li>
</ul>
<h4 id="casatwy组件化方案"><a href="#casatwy组件化方案" class="headerlink" title="casatwy组件化方案"></a>casatwy组件化方案</h4><h6 id="整体架构-1"><a href="#整体架构-1" class="headerlink" title="整体架构"></a>整体架构</h6><p>casatwy组件化方案分为两种调用方式，远程调用和本地调用，对于两个不同的调用方式分别对应两个接口。</p>
<ul>
<li>远程调用通过AppDelegate代理方法传递到当前应用后，调用远程接口并在内部做一些处理，处理完成后会在远程接口内部调用本地接口，以实现本地调用为远程调用服务。</li>
<li>本地调用由performTarget:action:params:方法负责，但调用方一般不直接调用performTarget:方法。CTMediator会对外提供明确参数和方法名的方法，在方法内部调用performTarget:方法和参数的转换。</li>
</ul>
<p><img src="/images/zjhjgmt/casatwyzjhjg.png" alt=""></p>
<h6 id="架构设计思路"><a href="#架构设计思路" class="headerlink" title="架构设计思路"></a>架构设计思路</h6><p>casatwy是通过CTMediator类实现组件化的，在此类中对外提供明确参数类型的接口，接口内部通过performTarget方法调用服务方组件的Target、Action。由于CTMediator类的调用是通过runtime主动发现服务的，所以服务方对此类是完全解耦的。</p>
<p>但如果CTMediator类对外提供的方法都放在此类中，将会对CTMediator造成极大的负担和代码量。解决方法就是对每个服务方组件创建一个CTMediator的Category，并将对服务方的performTarget调用放在对应的Category中，这些Category都属于CTMediator中间件，从而实现了感官上的接口分离。</p>
<p><img src="/images/zjhjgmt/casatwyzjxj.png" alt=""></p>
<p>（casatwy组件化实现细节）</p>
<p>对于服务方的组件来说，每个组件都提供一个或多个Target类，在Target类中声明Action方法。Target类是当前组件对外提供的一个“服务类”，Target将当前组件中所有的服务都定义在里面，CTMediator通过runtime主动发现服务。</p>
<p>在Target中的所有Action方法，都只有一个字典参数，所以可以传递的参数很灵活，这也是casatwy提出的去Model化的概念。在Action的方法实现中，对传进来的字典参数进行解析，再调用组件内部的类和方法。</p>
<h6 id="架构分析"><a href="#架构分析" class="headerlink" title="架构分析"></a>架构分析</h6><p>casatwy为我们提供了一个<a href="https://github.com/casatwy/CTMediator" target="_blank" rel="external">Demo</a>，通过这个Demo可以很好的理解<strong>casatwy</strong>的设计思路，下面按照我的理解讲解一下这个Demo。</p>
<p><img src="/images/zjhjgmt/wjml.png" alt=""></p>
<p>（文件目录）</p>
<p>打开Demo后可以看到文件目录非常清楚，在上图中用蓝框框出来的就是中间件部分，红框框出来的就是业务组件部分。我对每个文件夹做了一个简单的注释，包含了其在架构中的职责。</p>
<p>在CTMediator中定义远程调用和本地调用的两个方法，其他业务相关的调用由Category完成。</p>
<pre><code>// 远程App调用入口
- (id)performActionWithUrl:(NSURL *)url completion:(void(^)(NSDictionary *info))completion;
// 本地组件调用入口
- (id)performTarget:(NSString *)targetName action:(NSString *)actionName params:(NSDictionary *)params;
</code></pre><p>在CTMediator中定义的ModuleA的Category，对外提供了一个获取控制器并跳转的功能，下面是代码实现。由于casatwy的方案中使用performTarget的方式进行调用，所以涉及到很多硬编码字符串的问题，casatwy采取定义常量字符串来解决这个问题，这样管理也更方便。</p>
<pre><code>#import &quot;CTMediator+CTMediatorModuleAActions.h&quot;

NSString * const kCTMediatorTargetA = @&quot;A&quot;;
NSString * const kCTMediatorActionNativFetchDetailViewController = @&quot;nativeFetchDetailViewController&quot;;

@implementation CTMediator (CTMediatorModuleAActions)
- (UIViewController *)CTMediator_viewControllerForDetail {

   UIViewController *viewController = [self performTarget:kCTMediatorTargetA
                                                action:kCTMediatorActionNativFetchDetailViewController
                                                params:@{@&quot;key&quot;:@&quot;value&quot;}];
   if ([viewController isKindOfClass:[UIViewController class]]) {
     // view controller 交付出去之后，可以由外界选择是push还是present
      return viewController;
   }
   else {
     // 这里处理异常场景，具体如何处理取决于产品
     return [[UIViewController alloc] init];
   }
}
</code></pre><p>下面是ModuleA组件中提供的服务，被定义在Target_A类中，这些服务可以被CTMediator通过runtime的方式调用，这个过程就叫做发现服务。</p>
<p>我们发现，在这个方法中其实做了参数处理和内部调用的功能，这样就可以保证组件内部的业务不受外部影响，对内部业务没有侵入性。</p>
<pre><code>- (UIViewController *)Action_nativeFetchDetailViewController:(NSDictionary *)params {
   // 对传过来的字典参数进行解析，并调用ModuleA内部的代码
   DemoModuleADetailViewController *viewController = [[DemoModuleADetailViewController alloc] init];
   viewController.valueLabel.text = params[@&quot;key&quot;];
   return viewController;
}
</code></pre><h6 id="命名规范"><a href="#命名规范" class="headerlink" title="命名规范"></a>命名规范</h6><p>在大型项目中代码量比较大，需要避免命名冲突的问题。对于这个问题casatwy采取的是加前缀的方式，从casatwy的Demo中也可以看出，其组件ModuleA的Target命名为Target_A，被调用的Action命名为Action_nativeFetchDetailViewController:。</p>
<p>casatwy将类和方法的命名，都统一按照其功能做区分当做前缀，这样很好的将组件相关和组件内部代码进行了划分。</p>
<h3 id="标准组件化架构设计"><a href="#标准组件化架构设计" class="headerlink" title="标准组件化架构设计"></a>标准组件化架构设计</h3><p>这个章节叫做“标准组件化架构设计”，对于项目架构来说并没有绝对意义的标准之说。这里说到的“标准组件化架构设计”只是因为采取这样的方式的人比较多，且这种方式相比而言较合理。</p>
<p>在上面文章中提到了casatwy方案的CTMediator，蘑菇街方案的MGJRouter和ModuleManager，下面统称为中间件。</p>
<h4 id="整体架构-2"><a href="#整体架构-2" class="headerlink" title="整体架构"></a>整体架构</h4><p>组件化架构中，首先有一个主工程，主工程负责集成所有组件。每个组件都是一个单独的工程，创建不同的git私有仓库来管理，每个组件都有对应的开发人员负责开发。开发人员只需要关注与其相关组件的代码，其他业务代码和其无关，来新人也好上手。</p>
<p>组件的划分需要注意组件粒度，粒度根据业务可大可小。组件划分后属于业务组件，对于一些多个组件共同的东西，例如网络、数据库之类的，应该划分到单独的组件或基础组件中。对于图片或配置表这样的资源文件，应该再单独划分一个资源组件，这样避免资源的重复性。</p>
<p>服务方组件对外提供服务，由中间件调用或发现服务，服务对当前组件无侵入性，只负责对传递过来的数据进行解析和组件内调用的功能。需要被其他组件调用的组件都是服务方，服务方也可以调用其他组件的服务。</p>
<p>通过这样的组件划分，组件的开发进度不会受其他业务的影响，可以多个组件单独的并行开发。组件间的通信都交给中间件来进行，需要通信的类只需要接触中间件，而中间件不需要耦合其他组件，这就实现了组件间的解耦。中间件负责处理所有组件之间的调度，在所有组件之间起到控制核心的作用。</p>
<p>这套框架清晰的划分了不同组件，从整体架构上来约束开发人员进行组件化开发，避免某个开发人员偷懒直接引用头文件，产生组件间的耦合，破坏整体架构。假设以后某个业务发生大的改变，需要对相关代码进行重构，可以在单个组件进行重构。组件化架构降低了重构的风险，保证了代码的健壮性。</p>
<h4 id="组件集成"><a href="#组件集成" class="headerlink" title="组件集成"></a>组件集成</h4><p><img src="/images/zjhjgmt/zjhjgt.png" alt=""></p>
<p>（组件化架构图）</p>
<p>每个组件都是一个单独的工程，在组件开发完成后上传到git仓库。主工程通过Cocoapods集成各个组件，集成和更新组件时只需要pod update即可。这样就是把每个组件当做第三方来管理，管理起来非常方便。</p>
<p>Cocoapods可以控制每个组件的版本，例如在主项目中回滚某个组件到特定版本，就可以通过修改podfile文件实现。选择Cocoapods主要因为其本身功能很强大，可以很方便的集成整个项目，也有利于代码的复用。通过这种集成方式，可以很好的避免在传统项目中代码冲突的问题。</p>
<h4 id="集成方式"><a href="#集成方式" class="headerlink" title="集成方式"></a>集成方式</h4><p>对于组件化架构的集成方式，我在看完bang的博客后专门请教了一下bang。根据在微博上和bang的聊天以及其他博客中的学习，在主项目中集成组件主要分为两种方式——源码和framework，但都是通过CocoaPods来集成。<br>无论是用CocoaPods管理源码，还是直接管理framework，效果都是一样的，都是可以直接进行pod update之类的操作的。</p>
<p>这两种组件集成方案，实践中也是各有利弊。直接在主工程中集成代码文件，可以在主工程中进行调试。集成framework的方式，可以加快编译速度，而且对每个组件的代码有很好的保密性。如果公司对代码安全比较看重，可以考虑framework的形式，但framework不利于主工程中的调试。</p>
<p>例如手机QQ或者支付宝这样的大型程序，一般都会采取framework的形式。而且一般这样的大公司，都会有自己的组件库，这个组件库往往可以代表一个大的功能或业务组件，直接添加项目中就可以使用。关于组件化库在后面讲淘宝组件化架构的时候会提到。</p>
<h4 id="不推荐的集成方式"><a href="#不推荐的集成方式" class="headerlink" title="不推荐的集成方式"></a>不推荐的集成方式</h4><p>之前有些项目是直接用workspace的方式集成的，或者直接在原有项目中建立子项目，直接做文件引用。但这两点都是不建议做的，因为没有真正意义上实现业务组件的剥离，只是像之前的项目一样从文件目录结构上进行了划分。</p>
<h3 id="组件化开发总结"><a href="#组件化开发总结" class="headerlink" title="组件化开发总结"></a>组件化开发总结</h3><p>对于项目架构来说，一定要建立于业务之上来设计架构。不同的项目业务不同，组件化方案的设计也会不同，应该设计最适合公司业务的架构。</p>
<h4 id="架构对比"><a href="#架构对比" class="headerlink" title="架构对比"></a>架构对比</h4><p>在除蘑菇街Protocol方案外，其他两种方案都或多或少的存在硬编码问题，硬编码如果量比较大的话挺麻烦的。<br>在casatwy的CTMediator方案中需要硬编码Target、Action字符串，只不过这个缺陷被封闭在中间件里面了，将这些字符串都统一定义为常量，外界使用不需要接触到硬编码。蘑菇街的MGJRouter的方案也是一样的，也有硬编码URL的问题，蘑菇街可能也做了类似的处理。</p>
<p>casatwy和蘑菇街提出的两套组件化方案，大体结构是类似的，三套方案都分为调用方、中间件、服务方，只是在具体实现过程中有些不同。例如Protocol方案在中间件中加入了Protocol文件，casatwy的方案在中间件中加入了Category。<br>三种方案内部都有容错处理，所以三种方案的稳定性都是比较好的，而且都可以拿出来单独运行，在服务方不存在的情况下也不会有问题。</p>
<p>在三套方案中，服务方都对外提供一个供外界调用的接口类，这个类中实现组件对外提供的服务，中间件通过接口类来实现组件间的通信。在此类中统一定义对外提供的服务，外界调用时就知道服务方可以做什么。</p>
<p>调用流程也不大一样，蘑菇街的两套方案都需要注册操作，无论是Block还是Protocol都需要注册后才可以提供服务。而casatwy的方案则不需要，直接通过runtime调用。casatwy的方案实现了真正的对服务方解耦，而蘑菇街的两套方案则没有，对服务方和调用方都造成了耦合。</p>
<p>我认为三套方案中，Protocol方案是调用和维护最麻烦的一套方案。维护时需要同时维护Protocol、接口类两部分。而且调用时需要将服务方的接口类返回给调用方，并由调用方执行一系列调用逻辑，调用一个服务的逻辑非常复杂，这在开发中是非常影响开发效率的。</p>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>下面是组件化开发中的一个小总结，也是开发过程中的一些注意点。</p>
<ul>
<li><p>在MGJRouter方案中，是通过调用OpenURL:方法并传入URL来发起调用。鉴于URL协议名等固定格式，可以通过判断协议名的方式，使用配置表控制H5和native的切换，配置表可以从后台更新，只需要将协议名更改一下即可</p>
<pre><code>mgj://detail?id=123456
http://www.mogujie.com/detail?id=123456
</code></pre></li>
</ul>
<p>假设现在线上的native组件出现严重bug，在后台将配置文件中原有的本地URL换成H5的URL，并更新客户端配置文件。在调用MGJRouter时传入这个H5的URL即可完成切换，MGJRouter判断如果传进来的是一个H5的URL就直接跳转webView。而且URL可以传递参数给MGJRouter，只需要MGJRouter内部做参数截取即可。</p>
<ul>
<li>casatwy方案和蘑菇街Protocol方案，都提供了传递明确类型参数的方法。在MGJRouter方案中，传递参数主要是通过类似GET请求一样在URL后面拼接参数，和在字典中传递参数两种方式组成。这两种方式会造成传递参数类型不明确，传递参数类型受限(GET请求不能传递对象)等问题，后来使用Protocol方案弥补这个问题。</li>
<li>组件化开发可以很好的提升代码复用性，组件可以直接拿到其他项目中使用，这个优点在下面淘宝架构中会着重讲一下。</li>
<li>对于调试工作，应该放在每个组件中完成。单独的业务组件可以直接提交给测试提测，这样测试起来也比较方便。最后组件开发完成并测试通过后，再将所有组件更新到主项目，提交给测试进行集成测试即可。</li>
<li>使用组件化架构开发，组件间的通信都是有成本的。所以尽量将业务封装在组件内部，对外只提供简单的接口。即“高内聚、低耦合”原则。</li>
<li>把握好划分粒度的细化程度，太细则项目过于分散，太大则项目组件臃肿。但是项目都是从小到大的一个发展过程，所以不断进行重构是掌握这个组件的细化程度最好的方式。</li>
</ul>
<h4 id="我公司架构"><a href="#我公司架构" class="headerlink" title="我公司架构"></a>我公司架构</h4><p>下面就简单说说我公司项目架构，公司项目是一个地图导航应用，业务层之下的基础组件占比较大。且基础组件相对比较独立，对外提供了很多调用接口。刚开始想的是采用MGJRouter的方案，但如果这些调用都通过Router进行，开发起来比较复杂，反而会适得其反。最主要我们项目也并不是非常大，没必要都用Router转发。</p>
<p>对于这个问题，公司项目的架构设计是：层级架构+组件化架构，组件化架构处于层级架构的最上层，也就是业务层。采取这种结构混合的方式进行整体架构，这个对于公共组件的管理和层级划分比较有利，符合公司业务需求。</p>
<p><img src="/images/zjhjgmt/gszjhjg.png" alt=""></p>
<p>（公司组件化架构）</p>
<p>对于业务层级依然采用组件化架构的设计，这样可以充分利用组件化架构的优势，对项目组件间进行解耦。在上层和下层的调用中，下层的功能组件应该对外开放一个接口类，在接口类中声明所有的服务，实现上层调用当前组件的一个中转，上层直接调用接口类。这样做的好处在于，如果下层发生改变不会对上层造成影响，而且也省去了部分Router转发的工作。</p>
<p>在设计层级架构时，需要注意只能上层对下层依赖，下层对上层不能有依赖，下层中不要包含上层业务逻辑。对于项目中存在的公共资源和代码，应该将其下沉到下层中。</p>
<h4 id="为什么这么做？"><a href="#为什么这么做？" class="headerlink" title="为什么这么做？"></a>为什么这么做？</h4><p>首先就像我刚才说的，我公司项目并不是很大，根本没必要拆分的那么彻底。</p>
<p>因为组件化开发有一个很重要的原因就是解耦合，如果我做到了底层不对上层依赖，这样就已经解除了上下层的相互耦合。而且上层对下层进行调用的时候，也不是直接调用下层，通过一个接口类进行中转，实现了下层的改变对上层无影响，这也是上层对下层解耦的表现。</p>
<p>所以对于第三方就不用说了，上层直接调用下层的第三方也是没问题的，这都是解耦的。</p>
<h4 id="模型类怎么办，放在哪合适？"><a href="#模型类怎么办，放在哪合适？" class="headerlink" title="模型类怎么办，放在哪合适？"></a>模型类怎么办，放在哪合适？</h4><p>casatwy对模型类的观点是去Model化，简单来说就是用字典代替Model存储数据。这对于组件化架构来说，是解决组件之间数据传递的一个很好的方法。</p>
<p>因为模型类是关乎业务的，理论上必须放在业务层也就是业务组件这一层。但是要把模型对象从一个组件中当做参数传递到另一个组件中，模型类放在调用方和服务方的哪个组件都不太合适，而且有可能不只两个组件使用到这个模型对象。这样的话在其他组件使用模型对象，必然会造成引用和耦合。</p>
<p>那么如果把模型类放在Router中，这样会造成Router耦合了业务，造成业务的侵入性。如果在用到这个模型对象的所有组件中，都分别维护一份相同的模型类，这样之后业务发生改变模型类就会很麻烦。</p>
<h4 id="那应该怎么办呢？"><a href="#那应该怎么办呢？" class="headerlink" title="那应该怎么办呢？"></a>那应该怎么办呢？</h4><p>如果将模型类单独拉出来，定义一个模型组件呢？这个看起来比较可行，将这个定义模型的组件下沉到下层，模型组件不包含业务，只声明模型对象的类。但是一般组件的模型对象都是当前组件内使用的，将模型对象传递给其他组件的需求非常少，那所有的模型类都定义到模型组件吗？</p>
<p>对于这个问题，我建议在项目开发中将模型类还定义在当前业务组件中，在组件间传递模型对象时进行去Model化，传递字典类型的参数。<br>上面只是思考，恰巧我公司持久化方案用的是CoreData，所有模型的定义都在CoreData组件中，这样就避免了业务层组件之间因为模型类的耦合。</p>
<h3 id="滴滴组件化架构"><a href="#滴滴组件化架构" class="headerlink" title="滴滴组件化架构"></a>滴滴组件化架构</h3><p>之前看过滴滴iOS负责人李贤辉的<a href="http://mp.weixin.qq.com/s?__biz=MzA3ODg4MDk0Ng==&amp;mid=402854111&amp;idx=1&amp;sn=5876e615fabd6d921285d904e16670fb&amp;scene=1&amp;srcid=031694opQo3vCeGvWF5Gu62l#rd" target="_blank" rel="external">技术分享</a>，分享的是滴滴iOS客户端的架构发展历程，下面简单总结一下。</p>
<h4 id="发展历程"><a href="#发展历程" class="headerlink" title="发展历程"></a>发展历程</h4><p>滴滴在最开始的时候架构较混乱。然后在2.0时期重构为MVC架构，使项目划分更加清晰。在3.0时期上线了新的业务线，这时采用的游戏开发中的状态机机制，暂时可以满足现有业务。</p>
<p>然而在后期不断上线顺风车、代驾、巴士等多条业务线的情况下，现有架构变得非常臃肿，代码耦合严重。从而在2015年开始了代号为“The One”的方案，这套方案就是滴滴的组件化方案。</p>
<h4 id="架构设计-1"><a href="#架构设计-1" class="headerlink" title="架构设计"></a>架构设计</h4><p>滴滴的组件化方案，和蘑菇街方案类似，也是通过私有CocoaPods来管理各个组件。将整个项目拆分为业务部分和技术部分，业务部分包括专车、拼车、巴士等业务模块，每个业务模块就是一个单独的组件，使用一个pods管理。技术部分则分为登录分享、网络、缓存这样的一些基础组件，分别使用不同的pods管理。</p>
<p>组件间通信通过ONERouter中间件进行通信，ONERouter类似于MGJRouter，担负起协调和调用各个组件的作用。组件间通信通过OpenURL方法，来进行对应的调用。ONERouter内部保存一份Class-URL的映射表，通过URL找到Class并发起调用，Class的注册放在+load方法中进行。</p>
<p>滴滴在组件内部的业务模块中，模块内部使用MVVM+MVCS混合架构，两种架构都是MVC的衍生版本。其中MVCS中的Store负责数据相关逻辑，例如订单状态、地址管理等数据处理。通过MVVM中的VM给控制器瘦身，最后Controller的代码量就很少了。</p>
<h4 id="滴滴首页分析"><a href="#滴滴首页分析" class="headerlink" title="滴滴首页分析"></a>滴滴首页分析</h4><p>滴滴文章中说道首页只能有一个地图实例，这在很多地图导航相关应用中都是这样做的。滴滴首页主控制器持有导航栏和地图，每个业务线首页控制器都添加在主控制器上，并且业务线控制器背景都设置为透明，将透明部分响应事件传递到下面的地图中，只响应属于自己的响应事件。</p>
<p>由主控制器来切换各个业务线首页，切换页面后根据不同的业务线来更新地图数据。</p>
<h3 id="淘宝组件化架构"><a href="#淘宝组件化架构" class="headerlink" title="淘宝组件化架构"></a>淘宝组件化架构</h3><p>本章节源自于宗心在阿里技术沙龙上的一次<a href="https://yq.aliyun.com/articles/129" target="_blank" rel="external">分享</a></p>
<h4 id="架构发展"><a href="#架构发展" class="headerlink" title="架构发展"></a>架构发展</h4><p>淘宝iOS客户端初期是单工程的普通项目，但随着业务的飞速发展，现有架构并不能承载越来越多的业务需求，导致代码间耦合很严重。后期开发团队对其不断进行重构，淘宝iOS和Android两个平台，除了某个平台特有的一些特性或某些方案不便实施之外，大体架构都是差不多的。</p>
<h6 id="发展历程："><a href="#发展历程：" class="headerlink" title="发展历程："></a>发展历程：</h6><ul>
<li>刚开始是普通的单工程项目，以传统的MVC架构进行开发。随着业务不断的增加，导致项目非常臃肿、耦合严重。</li>
<li>2013年淘宝开启“all in 无线”计划，计划将淘宝变为一个大的平台，将阿里系大多数业务都集成到这个平台上，造成了业务的大爆发。</li>
<li>淘宝开始实行插件化架构，将每个业务模块划分为一个组件，将组件以framework二方库的形式集成到主工程。但这种方式并没有做到真正的拆分，还是在一个工程中使用git进行merge，这样还会造成合并冲突、不好回退等问题。</li>
<li>迎来淘宝移动端有史以来最大的重构，将其重构为组件化架构。将每个模块当做一个组件，每个组件都是一个单独的项目，并且将组件打包成framework。主工程通过podfile集成所有组件framework，实现业务之间真正的隔离，通过CocoaPods实现组件化架构。</li>
</ul>
<h4 id="架构优势"><a href="#架构优势" class="headerlink" title="架构优势"></a>架构优势</h4><p>淘宝是使用git来做源码管理的，在插件化架构时需要尽可能避免merge操作，否则在大团队中协作成本是很大的。而使用CocoaPods进行组件化开发，则避免了这个问题。</p>
<p>在CocoaPods中可以通过podfile很好的配置各个组件，包括组件的增加和删除，以及控制某个组件的版本。使用CocoaPods的原因，很大程度是为了解决大型项目中，代码管理工具merge代码导致的冲突。并且可以通过配置podfile文件，轻松配置项目。</p>
<p>每个组件工程有两个target，一个负责编译当前组件和运行调试，另一个负责打包framework。先在组件工程做测试，测试完成后再集成到主工程中集成测试。</p>
<p>每个组件都是一个独立app，可以独立开发、测试，使得业务组件更加独立，所有组件可以并行开发。下层为上层提供能满足需求的底层库，保证上层业务层可以正常开发，并将底层库封装成framework集成到项目中。</p>
<p>使用CocoaPods进行组件集成的好处在于，在集成测试自己组件时，可以直接将本地主工程podfile文件中的当前组件指向本地，就可以直接进行集成测试，不需要提交到服务器仓库。</p>
<h4 id="淘宝四层架构"><a href="#淘宝四层架构" class="headerlink" title="淘宝四层架构"></a>淘宝四层架构</h4><p><img src="/images/zjhjgmt/tbscjg.png" alt=""></p>
<p>淘宝四层架构(图片来自淘宝技术分享)</p>
<p>淘宝架构的核心思想是一切皆组件，将工程中所有代码都抽象为组件。</p>
<p>淘宝架构主要分为四层，最上层是组件Bundle(业务组件)，依次往下是容器(核心层)，中间件Bundle(功能封装)，基础库Bundle(底层库)。容器层为整个架构的核心，负责组件间的调度和消息派发。</p>
<h4 id="总线设计"><a href="#总线设计" class="headerlink" title="总线设计"></a>总线设计</h4><p>总线设计：URL路由+服务+消息。统一所有组件的通信标准，各个业务间通过总线进行通信。</p>
<p><img src="/images/zjhjgmt/zxsj.png" alt=""></p>
<p>总线设计(图片来自淘宝技术分享)</p>
<p>URL可以请求也可以接受返回值，和MGJRouter差不多。URL路由请求可以被解析就直接拿来使用，如果不能被解析就跳转H5页面。这样就完成了一个对不存在组件调用的兼容，使用户手中比较老的版本依然可以显示新的组件。</p>
<p>服务提供一些公共服务，由服务方组件负责实现，通过Protocol实现。消息负责统一发送消息，类似于通知也需要注册。</p>
<h4 id="Bundle-App"><a href="#Bundle-App" class="headerlink" title="Bundle App"></a>Bundle App</h4><p><img src="/images/zjhjgmt/BundleApp.png" alt=""></p>
<p>Bundle App(图片来自淘宝技术分享)</p>
<p>淘宝提出Bundle App的概念，可以通过已有组件，进行简单配置后就可以组成一个新的app出来。解决了多个应用业务复用的问题，防止重复开发同一业务或功能。</p>
<p>Bundle即App，容器即OS，所有Bundle App被集成到OS上，使每个组件的开发就像app开发一样简单。这样就做到了从巨型app回归普通app的轻盈，使大型项目的开发问题彻底得到了解决。</p>
<h4 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h4><p>现在H5技术比较火，好多应用都用H5来完成一些页面的开发，H5的跨平台和实时更新等是非常大的优点，但其性能和交互也是缺点。如果以后客户端能够发展到可以动态部署线上代码，不用打包上线应用市场，直接就可以做到原生应用更新，这样就可以解决原生应用最大的痛点。这段时间公司项目比较忙，有时间我打算研究一下这个技术点😄。</p>
<p>Demo地址：蘑菇街和casatwy组件化方案，其Github上都给出了Demo，这里就贴出其Github地址了。</p>
<p><a href="https://github.com/mogujie/MGJRouter" target="_blank" rel="external">蘑菇街-MGJRouter</a><br><a href="https://github.com/casatwy/CTMediator" target="_blank" rel="external">casatwy-CTMediator</a></p>

      
    </div>
    <div class="article-info article-info-index">
      
      <a href="/2016/11/08/组件化架构漫谈/" class="archive-article-date">
  	<time datetime="2016-11-08T05:59:32.000Z" itemprop="datePublished"><i class="icon-clock"></i>2016-11-08</time>
</a>
      
	<div class="article-tag tagcloud">
		<i class="icon-price-tags"></i>
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/iOS/">iOS</a></li></ul>
	</div>

      

      <div class="clearfix"></div>
    </div>
  </div>
</article>

  
<nav id="article-nav">
  
  
    <a href="/2016/11/08/iOS数据采集/" id="article-nav-older" class="article-nav-link-wrap">
      <div class="article-nav-title">iOS数据采集</div>
      <i class="icon-circle-right"></i>
    </a>
  
</nav>











      </div>
      <footer id="footer">
  <div class="outer">
    <div id="footer-info">
    	<div class="footer-left">
    		&copy; 2016 Gengjf
    	</div>
      	<div class="footer-right">
      		<a href="http://hexo.io/" target="_blank">Hexo</a>  Theme <a href="https://github.com/litten/hexo-theme-yilia" target="_blank">Yilia</a>
      	</div>
    </div>
  </div>
</footer>

    </div>
    <script>
	var yiliaConfig = {
		fancybox: true,
		mathjax: false,
		animate: true,
		isHome: false,
		isPost: true,
		isArchive: false,
		isTag: false,
		isCategory: false,
		open_in_new: false,
		root: "/",
		innerArchive: true
	}
</script>

<script src="/./main.js"></script>


    
<div class="tools-col">
  <ul class="btn-wrap">
    
      <li class="chose" data-hook="tools-section-all"><span class="text">全部</span><i class="icon-book"></i></li>
    
    
    
    
      <li data-hook="tools-section-me"><span class="text">我</span><i class="icon-smile"></i></li>
    
  </ul>
  <div class="tools-wrap">
    
    	<section class="tools-section tools-section-all chose">
    	</section>
    

    

    

    
    	<section class="tools-section tools-section-me">
  	  	
  	  		<div class="aboutme-wrap" id="js-aboutme">很懒，暂时没写</div>
  	  	
    	</section>
    
  </div>
  
</div>
    <!-- Root element of PhotoSwipe. Must have class pswp. -->
<div class="pswp" tabindex="-1" role="dialog" aria-hidden="true">

    <!-- Background of PhotoSwipe. 
         It's a separate element as animating opacity is faster than rgba(). -->
    <div class="pswp__bg"></div>

    <!-- Slides wrapper with overflow:hidden. -->
    <div class="pswp__scroll-wrap">

        <!-- Container that holds slides. 
            PhotoSwipe keeps only 3 of them in the DOM to save memory.
            Don't modify these 3 pswp__item elements, data is added later on. -->
        <div class="pswp__container">
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
        </div>

        <!-- Default (PhotoSwipeUI_Default) interface on top of sliding area. Can be changed. -->
        <div class="pswp__ui pswp__ui--hidden">

            <div class="pswp__top-bar">

                <!--  Controls are self-explanatory. Order can be changed. -->

                <div class="pswp__counter"></div>

                <button class="pswp__button pswp__button--close" title="Close (Esc)"></button>

                <button class="pswp__button pswp__button--share" style="display:none" title="Share"></button>

                <button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>

                <button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>

                <!-- Preloader demo http://codepen.io/dimsemenov/pen/yyBWoR -->
                <!-- element will get class pswp__preloader--active when preloader is running -->
                <div class="pswp__preloader">
                    <div class="pswp__preloader__icn">
                      <div class="pswp__preloader__cut">
                        <div class="pswp__preloader__donut"></div>
                      </div>
                    </div>
                </div>
            </div>

            <div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
                <div class="pswp__share-tooltip"></div> 
            </div>

            <button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
            </button>

            <button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)">
            </button>

            <div class="pswp__caption">
                <div class="pswp__caption__center"></div>
            </div>

        </div>

    </div>

</div>
  </div>
</body>
</html>